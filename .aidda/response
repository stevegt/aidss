File: /home/stevegt/lab/aidss/cmd/aidss/main.go
```go
package main

import (
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync"

	"github.com/fsnotify/fsnotify"
	"github.com/google/uuid"
	"github.com/spf13/cobra"
	"rsc.io/pdf"

	"github.com/stevegt/aidss/llm"
	. "github.com/stevegt/goadapt"
)

var (
	mutex sync.Mutex // To handle concurrent access

	promptFn   = "prompt.txt"
	responseFn = "response.txt"
)

type Prompt struct {
	InFiles    []string
	OutFiles   []string
	SysMsg     string
	PromptText string
}

func main() {
	// Initialize and register providers
	llm.RegisterProviders()

	// Get available models from llm package
	models := llm.Models()

	// Initialize the command-line interface
	rootCmd := &cobra.Command{
		Use:   "decision_tool",
		Short: "Decision Support Tool",
		Run: func(cmd *cobra.Command, args []string) {
			watchPath, err := cmd.Flags().GetString("path")
			Ck(err)
			modelName, err := cmd.Flags().GetString("model")
			Ck(err)
			startDaemon(watchPath, modelName)
		},
	}

	// Make sure usage includes model names
	modelUsage := fmt.Sprintf("Model to use (%s)", strings.Join(models, ", "))

	// Define flags
	rootCmd.Flags().StringP("path", "p", ".", "Path to watch")
	rootCmd.Flags().StringP("model", "m", models[0], modelUsage)

	// Execute the root command
	if err := rootCmd.Execute(); err != nil {
		log.Fatal(err)
	}
}

// startDaemon starts the decision tool daemon. The daemon watches the file system for changes
// and responds to user messages and attachments.
func startDaemon(watchPath string, modelName string) {
	var err error

	// Set up the LLM client based on the model name
	client, err := llm.NewClient(modelName)
	if err != nil {
		log.Fatal(err)
	}

	// Start the file watcher
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}
	defer watcher.Close()

	done := make(chan bool)

	// Handle file system events
	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					// Watcher has been closed
					return
				}
				if event.Op&fsnotify.Write == fsnotify.Write {
					// handle file write events
					if filepath.Base(event.Name) == promptFn {
						log.Println("Detected change in:", event.Name)
						handleUserMessage(filepath.Dir(event.Name), client, watchPath)
					}
					if filepath.Ext(event.Name) == ".pdf" {
						log.Println("Detected PDF attachment:", event.Name)
						handlePDFAttachment(event.Name, extractTextFromPDF)
					}
				}
				if event.Op&fsnotify.Create == fsnotify.Create {
					// If a new directory is created, add it to the watcher
					fi, err := os.Stat(event.Name)
					if err == nil && fi.IsDir() {
						watcher.Add(event.Name)
						log.Println("Added new directory to watcher:", event.Name)
					}
				}
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}
				log.Println("error:", err)
			}
		}
	}()

	// Watch the root path
	err = addWatcherRecursive(watcher, watchPath)
	if err != nil {
		log.Fatal(err)
	}

	log.Println("Started watching:", watchPath)
	<-done
}

// addWatcherRecursive recursively adds a directory and its subdirectories to the watcher
func addWatcherRecursive(watcher *fsnotify.Watcher, path string) error {
	err := watcher.Add(path)
	if err != nil {
		return err
	}

	files, err := ioutil.ReadDir(path)
	if err != nil {
		return err
	}

	for _, file := range files {
		if file.IsDir() {
			err = addWatcherRecursive(watcher, filepath.Join(path, file.Name()))
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// parsePromptFile parses the prompt file and returns a Prompt struct
func parsePromptFile(filename string) (*Prompt, error) {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	content := string(data)
	prompt := &Prompt{}

	// Split headers and prompt text
	parts := strings.SplitN(content, "\n\n", 2)
	if len(parts) != 2 {
		return nil, fmt.Errorf("Invalid prompt file format")
	}

	headerText := parts[0]
	prompt.PromptText = parts[1]

	headers := make(map[string]string)
	lines := strings.Split(headerText, "\n")
	var currentHeader string
	var currentValue strings.Builder

	for _, line := range lines {
		if strings.TrimSpace(line) == "" {
			// Skip empty lines
			continue
		}

		if !strings.HasPrefix(line, " ") && !strings.HasPrefix(line, "\t") {
			// New header line
			if currentHeader != "" {
				// Save previous header
				headers[currentHeader] = currentValue.String()
			}
			colonIndex := strings.Index(line, ":")
			if colonIndex == -1 {
				// Headers without colon, e.g., "In:"
				currentHeader = strings.TrimSpace(line)
				currentValue.Reset()
			} else {
				currentHeader = strings.TrimSpace(line[:colonIndex])
				currentValue.Reset()
				currentValue.WriteString(strings.TrimSpace(line[colonIndex+1:]))
			}
		} else {
			// Continuation line
			if currentHeader == "" {
				return nil, fmt.Errorf("Continuation line without preceding header")
			}
			currentValue.WriteString(" ")
			currentValue.WriteString(strings.TrimSpace(line))
		}
	}

	// Save last header
	if currentHeader != "" {
		headers[currentHeader] = currentValue.String()
	}

	// Now process headers
	for key, value := range headers {
		switch key {
		case "In":
			prompt.InFiles = append(prompt.InFiles, strings.Fields(value)...)
		case "Out":
			prompt.OutFiles = append(prompt.OutFiles, strings.Fields(value)...)
		case "Sysmsg":
			prompt.SysMsg = value
		default:
			// Ignore unknown headers
		}
	}

	return prompt, nil
}

// handleUserMessage handles a user message by generating a response from the language model
func handleUserMessage(path string, client llm.Client, watchPath string) {
	mutex.Lock()
	defer mutex.Unlock()

	messagePath := filepath.Join(path, promptFn)
	prompt, err := parsePromptFile(messagePath)
	if err != nil {
		log.Println("Error parsing prompt file:", err)
		return
	}

	// Build context messages
	contextMessages := buildContextMessages(path, watchPath)

	// Add system message if provided
	if prompt.SysMsg != "" {
		contextMessages = append(contextMessages, llm.Message{
			Role:    llm.ChatMessageRoleSystem,
			Content: prompt.SysMsg,
		})
	}

	// Read and include contents of InFiles
	inFilesContent, err := readInFilesContent(prompt.InFiles, watchPath)
	if err != nil {
		log.Println("Error reading In files:", err)
		return
	}

	// Build the user message
	userContent := Spf("%s\n\n", prompt.PromptText)
	if len(inFilesContent) > 0 {
		userContent += "The following files are attached:\n" + inFilesContent + "\n"
	}

	// Append the new user message
	contextMessages = append(contextMessages, llm.Message{
		Role:    llm.ChatMessageRoleUser,
		Content: userContent,
	})

	response, err := getLLMResponse(contextMessages, client)
	if err != nil {
		log.Println("Error getting LLM response:", err)
		return
	}

	// Save the LLM response
	responsePath := filepath.Join(path, responseFn)
	err = ioutil.WriteFile(responsePath, []byte(response), 0644)
	if err != nil {
		log.Println("Error writing LLM response:", err)
	}

	log.Println("LLM response written to:", responsePath)

	// Parse the LLM response for updated files
	err = processLLMResponse(response, prompt.OutFiles, watchPath)
	if err != nil {
		log.Println("Error processing LLM response:", err)
	}
}

func readInFilesContent(inFiles []string, watchPath string) (string, error) {
	var contentBuilder strings.Builder
	parentDir := filepath.Dir(watchPath)
	for _, relPath := range inFiles {
		absPath := filepath.Join(parentDir, relPath)
		data, err := ioutil.ReadFile(absPath)
		if err != nil {
			return "", fmt.Errorf("error reading file %s: %v", absPath, err)
		}
		contentBuilder.WriteString(fmt.Sprintf("<IN filename=\"%s\">\n%s\n</IN>\n", relPath, string(data)))
	}
	return contentBuilder.String(), nil
}

func processLLMResponse(response string, outFiles []string, watchPath string) error {
	parentDir := filepath.Dir(watchPath)

	// Wrap the response in a root element to make it valid XML
	wrappedResponse := "<root>" + response + "</root>"

	// Parse the XML
	type OutFile struct {
		Filename string `xml:"filename,attr"`
		Content  string `xml:",innerxml"`
	}
	type Root struct {
		OutFiles []OutFile `xml:"OUT"`
	}

	var root Root
	err := xml.Unmarshal([]byte(wrappedResponse), &root)
	if err != nil {
		return fmt.Errorf("error parsing LLM response XML: %v", err)
	}

	// Map of filename to content
	outFileContents := make(map[string]string)
	for _, outFile := range root.OutFiles {
		outFileContents[outFile.Filename] = outFile.Content
	}

	// For each file in outFiles, check if we have content
	for _, filename := range outFiles {
		content, ok := outFileContents[filename]
		if !ok {
			log.Printf("Warning: Filename %s specified in Out: section but not found in LLM response", filename)
			continue
		}

		// Write the content to the corresponding file
		absPath := filepath.Join(parentDir, filename)
		err := ioutil.WriteFile(absPath, []byte(content), 0644)
		if err != nil {
			log.Printf("Error writing to file %s: %v", absPath, err)
			continue
		}
		log.Printf("Updated file written to: %s", absPath)
	}

	// Warn if there are files in the LLM response not specified in OutFiles
	outFilesSet := make(map[string]struct{})
	for _, filename := range outFiles {
		outFilesSet[filename] = struct{}{}
	}
	for filename := range outFileContents {
		if _, ok := outFilesSet[filename]; !ok {
			log.Printf("Warning: Filename %s found in LLM response but not specified in Out: section", filename)
		}
	}

	return nil
}

// buildContextMessages builds a list of chat messages from the root to the current directory
// to provide context to the language model
func buildContextMessages(path string, watchPath string) []llm.Message {
	var messages []llm.Message
	var paths []string

	// Collect paths from root to current directory
	currentPath := path
	for {
		paths = append([]string{currentPath}, paths...)
		if currentPath == watchPath {
			// stop at the watch path
			break
		}
		parentPath := filepath.Dir(currentPath)
		if parentPath == currentPath {
			// stop at the filesystem root
			break
		}
		currentPath = parentPath
	}

	// Build messages from collected paths
	for _, p := range paths {
		if content, err := ioutil.ReadFile(filepath.Join(p, promptFn)); err == nil {
			messages = append(messages, llm.Message{
				Role:    llm.ChatMessageRoleUser,
				Content: string(content),
			})
		}
		if content, err := ioutil.ReadFile(filepath.Join(p, responseFn)); err == nil {
			messages = append(messages, llm.Message{
				Role:    llm.ChatMessageRoleAssistant,
				Content: string(content),
			})
		}
	}

	return messages
}

func getAttachmentsContent(path string) (string, error) {
	var contentBuilder strings.Builder

	files, err := ioutil.ReadDir(path)
	if err != nil {
		return "", err
	}

	for _, file := range files {
		if strings.HasSuffix(file.Name(), ".pdf.txt") {
			attachmentContent, err := ioutil.ReadFile(filepath.Join(path, file.Name()))
			if err != nil {
				return "", err
			}
			// Delimit attachments with unique XML tags
			contentBuilder.WriteString(fmt.Sprintf("<IN filename=\"%s\">\n%s\n</IN>\n", file.Name(), string(attachmentContent)))
		}
	}

	return contentBuilder.String(), nil
}

func getLLMResponse(messages []llm.Message, client llm.Client) (string, error) {
	ctx := context.Background()
	response, err := client.GenerateResponse(ctx, messages)
	if err != nil {
		return "", err
	}
	return response, nil
}

func handlePDFAttachment(pdfPath string, extractTextFunc func(string) (string, error)) {
	mutex.Lock()
	defer mutex.Unlock()

	text, err := extractTextFunc(pdfPath)
	if err != nil {
		log.Println("Error extracting text from PDF:", err)
		return
	}

	// Save extracted text alongside the PDF
	txtPath := pdfPath + ".txt"
	err = ioutil.WriteFile(txtPath, []byte(text), 0644)
	if err != nil {
		log.Println("Error writing extracted text:", err)
		return
	}

	log.Println("Extracted text from PDF saved to:", txtPath)
}

func extractTextFromPDF(pdfPath string) (string, error) {
	r, err := pdf.Open(pdfPath)
	if err != nil {
		return "", err
	}
	var text strings.Builder
	numPages := r.NumPage()
	for i := 1; i <= numPages; i++ {
		p := r.Page(i)
		if p.V.IsNull() {
			continue
		}
		content := p.Content()
		for _, txt := range content.Text {
			text.WriteString(txt.S + " ")
		}
	}
	return text.String(), nil
}

func createNewDecisionNode(parentPath, descriptor string) (string, error) {
	// Sanitize the descriptor to remove invalid characters
	sanitizedDescriptor := sanitizeDescriptor(descriptor)

	// Generate a unique identifier
	uuidStr := generateUUID()

	// Combine to create the directory name
	dirName := fmt.Sprintf("%s_%s", sanitizedDescriptor, uuidStr)
	newPath := filepath.Join(parentPath, dirName)

	err := os.Mkdir(newPath, 0755)
	if err != nil {
		return "", err
	}
	return newPath, nil
}

func sanitizeDescriptor(descriptor string) string {
	// Replace spaces with underscores, remove special characters
	descriptor = strings.ReplaceAll(descriptor, " ", "_")
	descriptor = strings.ReplaceAll(descriptor, "/", "_")
	descriptor = strings.ReplaceAll(descriptor, "\\", "_")
	// Add more replacements as needed
	return descriptor
}

func generateUUID() string {
	// Generate a UUID
	id := uuid.New()
	return id.String()
}

func summarizePath(path string, client llm.Client, watchPath string) {
	mutex.Lock()
	defer mutex.Unlock()

	messages := buildContextMessages(path, watchPath)
	var textBuilder strings.Builder
	for _, msg := range messages {
		textBuilder.WriteString(msg.Role + ": " + msg.Content + "\n")
	}
	text := textBuilder.String()

	summary, err := getSummary(text, client)
	if err != nil {
		log.Println("Error summarizing path:", err)
		return
	}

	summaryPath := filepath.Join(path, "summary.txt")
	err = ioutil.WriteFile(summaryPath, []byte(summary), 0644)
	if err != nil {
		log.Println("Error writing summary:", err)
	} else {
		log.Println("Summary written to:", summaryPath)
	}
}

func getSummary(text string, client llm.Client) (string, error) {
	summaryPrompt := fmt.Sprintf("Please provide a concise summary of the following conversation:\n\n%s", text)
	messages := []llm.Message{
		{
			Role:    llm.ChatMessageRoleUser,
			Content: summaryPrompt,
		},
	}
	return getLLMResponse(messages, client)
}

func updateMetrics(path string, metrics map[string]interface{}) {
	metricsPath := filepath.Join(path, "metrics.json")
	data, err := json.MarshalIndent(metrics, "", "  ")
	if err != nil {
		log.Println("Error marshalling metrics:", err)
		return
	}
	err = ioutil.WriteFile(metricsPath, data, 0644)
	if err != nil {
		log.Println("Error writing metrics:", err)
	} else {
		log.Println("Metrics updated at:", metricsPath)
	}
}
```
EOF_/home/stevegt/lab/aidss/cmd/aidss/main.go

File: /home/stevegt/lab/aidss/cmd/aidss/main_test.go
```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"testing"

	"github.com/davecgh/go-spew/spew"
	"github.com/fsnotify/fsnotify"
	"github.com/stevegt/aidss/llm"

	. "github.com/stevegt/goadapt"
)

func init() {
	// Initialize and register providers for testing
	llm.RegisterProvider("mock", llm.NewMockProvider())
}

func TestCreateNewDecisionNode(t *testing.T) {
	parentDir, err := ioutil.TempDir("", "test_decision_node")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(parentDir)

	descriptor := "Test Node"
	newPath, err := createNewDecisionNode(parentDir, descriptor)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if _, err := os.Stat(newPath); os.IsNotExist(err) {
		t.Fatalf("Expected directory %s to be created", newPath)
	}

	expectedPrefix := filepath.Join(parentDir, "Test_Node_")
	if !strings.HasPrefix(newPath, expectedPrefix) {
		t.Errorf("Expected directory name to start with %s, got %s", expectedPrefix, newPath)
	}
}

func TestHandleUserMessage(t *testing.T) {
	// Set up temporary directory
	tempDir, err := ioutil.TempDir("", "test_user_message")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// Create prompt.txt
	promptContent := `In:
 test_in.txt
Out:
 test_out.txt
Sysmsg: Test Sys Message
 Additional sys message line.

Test prompt text.`

	err = ioutil.WriteFile(filepath.Join(tempDir, "prompt.txt"), []byte(promptContent), 0644)
	if err != nil {
		t.Fatal(err)
	}

	// Create test_in.txt
	parentDir := filepath.Dir(tempDir)
	inFilePath := filepath.Join(parentDir, "test_in.txt")
	err = ioutil.WriteFile(inFilePath, []byte("Content of test_in.txt"), 0644)
	if err != nil {
		t.Fatal(err)
	}

	// Create the mock client
	var errClient error
	client, errClient := llm.NewClient("mock-model")
	if errClient != nil {
		t.Fatalf("Error creating mock client: %v", errClient)
	}

	// Mock mutex
	mutex = sync.Mutex{}

	// Call handleUserMessage
	handleUserMessage(tempDir, client, tempDir)

	// Check response.txt
	responsePath := filepath.Join(tempDir, "response.txt")
	data, err := ioutil.ReadFile(responsePath)
	if err != nil {
		t.Fatalf("Expected response.txt to be created, got error: %v", err)
	}

	if string(data) != "This is a mock response." {
		t.Errorf("Expected 'This is a mock response.', got '%s'", string(data))
	}
}

func TestParsePromptFile(t *testing.T) {
	promptContent := `In:
 file1.txt file2.txt
Out:
 output1.txt
 output2.txt
Sysmsg: This is a system message
 Continued sys message.

This is the prompt text.`

	tempFile, err := ioutil.TempFile("", "prompt_*.txt")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(tempFile.Name())

	_, err = tempFile.WriteString(promptContent)
	if err != nil {
		t.Fatal(err)
	}

	prompt, err := parsePromptFile(tempFile.Name())
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	expectedInFiles := []string{"file1.txt", "file2.txt"}
	expectedOutFiles := []string{"output1.txt", "output2.txt"}
	expectedSysMsg := "This is a system message Continued sys message."
	expectedPromptText := "This is the prompt text."

	if !equalStringSlices(prompt.InFiles, expectedInFiles) {
		t.Errorf("Expected InFiles %v, got %v", expectedInFiles, prompt.InFiles)
	}
	if !equalStringSlices(prompt.OutFiles, expectedOutFiles) {
		t.Errorf("Expected OutFiles %v, got %v", expectedOutFiles, prompt.OutFiles)
	}
	if prompt.SysMsg != expectedSysMsg {
		t.Errorf("Expected SysMsg '%s', got '%s'", expectedSysMsg, prompt.SysMsg)
	}
	if prompt.PromptText != expectedPromptText {
		t.Errorf("Expected PromptText '%s', got '%s'", expectedPromptText, prompt.PromptText)
	}
}

func equalStringSlices(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	m := make(map[string]int)
	for _, x := range a {
		m[x]++
	}
	for _, x := range b {
		if m[x] == 0 {
			return false
		}
		m[x]--
	}
	return true
}

func TestProcessLLMResponse(t *testing.T) {
	response := `<OUT filename="output1.txt">
Content for output1
</OUT>

<OUT filename="output2.txt">
Content for output2
</OUT>`

	tempDir, err := ioutil.TempDir("", "test_process_response")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	parentDir := filepath.Dir(tempDir)
	outFiles := []string{"output1.txt", "output2.txt"}

	err = processLLMResponse(response, outFiles, tempDir)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Check if files are written correctly
	for _, fname := range outFiles {
		absPath := filepath.Join(parentDir, fname)
		data, err := ioutil.ReadFile(absPath)
		if err != nil {
			t.Fatalf("Expected file %s to be created, got error: %v", absPath, err)
		}
		expectedContent := fmt.Sprintf("Content for %s", strings.TrimSuffix(fname, ".txt"))
		if string(data) != expectedContent {
			t.Errorf("Expected content '%s', got '%s'", expectedContent, string(data))
		}
	}
}

func TestBuildContextMessages(t *testing.T) {
	// Set up nested directories
	rootDir, err := ioutil.TempDir("", "test_context_messages")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(rootDir)

	subDir := filepath.Join(rootDir, "subdir")
	err = os.Mkdir(subDir, 0755)
	if err != nil {
		t.Fatal(err)
	}

	// Create prompt.txt and response.txt in root
	err = ioutil.WriteFile(filepath.Join(rootDir, "prompt.txt"), []byte("Root message"), 0644)
	if err != nil {
		t.Fatal(err)
	}
	err = ioutil.WriteFile(filepath.Join(rootDir, "response.txt"), []byte("Root response"), 0644)
	if err != nil {
		t.Fatal(err)
	}

	// Create prompt.txt and response.txt in subdir
	err = ioutil.WriteFile(filepath.Join(subDir, "prompt.txt"), []byte("Subdir message"), 0644)
	if err != nil {
		t.Fatal(err)
	}
	err = ioutil.WriteFile(filepath.Join(subDir, "response.txt"), []byte("Subdir response"), 0644)
	if err != nil {
		t.Fatal(err)
	}

	// Call buildContextMessages
	messages := buildContextMessages(subDir, rootDir)

	// Expected messages
	expectedMessages := []llm.Message{
		{Role: llm.ChatMessageRoleUser, Content: "Root message"},
		{Role: llm.ChatMessageRoleAssistant, Content: "Root response"},
		{Role: llm.ChatMessageRoleUser, Content: "Subdir message"},
		{Role: llm.ChatMessageRoleAssistant, Content: "Subdir response"},
	}

	if len(messages) != len(expectedMessages) {
		spew.Dump(messages)
		t.Fatalf("Expected %d messages, got %d", len(expectedMessages), len(messages))
	}

	for i, msg := range messages {
		if msg.Role != expectedMessages[i].Role || msg.Content != expectedMessages[i].Content {
			t.Errorf("Message %d expected %+v, got %+v", i, expectedMessages[i], msg)
		}
	}
}

func TestGetAttachmentsContent(t *testing.T) {
	// Set up temporary directory
	tempDir, err := ioutil.TempDir("", "test_attachments")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// Create attachment.pdf.txt
	attachmentContent := "Extracted text from PDF"
	err = ioutil.WriteFile(filepath.Join(tempDir, "attachment.pdf.txt"), []byte(attachmentContent), 0644)
	if err != nil {
		t.Fatal(err)
	}

	// Call getAttachmentsContent
	content, err := getAttachmentsContent(tempDir)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	expectedContent := "<IN filename=\"attachment.pdf.txt\">\n" + attachmentContent + "\n</IN>\n"
	if content != expectedContent {
		t.Errorf("Expected content:\n%s\nGot:\n%s", expectedContent, content)
	}
}

func TestGetLLMResponse(t *testing.T) {
	// Create the mock client
	var errClient error
	client, errClient := llm.NewClient("mock-model")
	if errClient != nil {
		t.Fatalf("Error creating mock client: %v", errClient)
	}

	// Mock messages
	messages := []llm.Message{
		{Role: llm.ChatMessageRoleUser, Content: "Hello"},
	}

	// Call getLLMResponse
	response, err := getLLMResponse(messages, client)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if response != "This is a mock response." {
		t.Errorf("Expected 'This is a mock response.', got '%s'", response)
	}
}

func TestHandlePDFAttachment(t *testing.T) {
	// Set up temporary directory
	tempDir, err := ioutil.TempDir("", "test_pdf_attachment")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// Create a fake PDF file (since we're not testing PDF parsing here)
	pdfPath := filepath.Join(tempDir, "attachment.pdf")
	err = ioutil.WriteFile(pdfPath, []byte("%PDF-1.4 Fake PDF content"), 0644)
	if err != nil {
		t.Fatal(err)
	}

	// Mock extractTextFromPDF function
	mockExtractText := func(pdfPath string) (string, error) {
		return "Extracted text", nil
	}

	// Call handlePDFAttachment
	handlePDFAttachment(pdfPath, mockExtractText)

	// Check if attachment.pdf.txt is created
	txtPath := pdfPath + ".txt"
	data, err := ioutil.ReadFile(txtPath)
	if err != nil {
		t.Fatalf("Expected %s to be created, got error: %v", txtPath, err)
	}

	if string(data) != "Extracted text" {
		t.Errorf("Expected 'Extracted text', got '%s'", string(data))
	}
}

func TestExtractTextFromPDF(t *testing.T) {
	// Since testing actual PDF extraction is complex, we'll test error handling
	// Attempt to extract text from a non-existent PDF
	_, err := extractTextFromPDF("non_existent.pdf")
	if err == nil {
		t.Errorf("Expected error when extracting from non-existent PDF")
	}
}

func TestSummarizePath(t *testing.T) {
	// Set up temporary directory
	tempDir, err := ioutil.TempDir("", "test_summarize")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// Create conversation files
	err = ioutil.WriteFile(filepath.Join(tempDir, "prompt.txt"), []byte("User message"), 0644)
	if err != nil {
		t.Fatal(err)
	}
	err = ioutil.WriteFile(filepath.Join(tempDir, "response.txt"), []byte("LLM response"), 0644)
	if err != nil {
		t.Fatal(err)
	}

	// Create the mock client
	var errClient error
	client, errClient := llm.NewClient("mock-model")
	if errClient != nil {
		t.Fatalf("Error creating mock client: %v", errClient)
	}

	// Call summarizePath
	summarizePath(tempDir, client, tempDir)

	// Check if summary.txt is created
	summaryPath := filepath.Join(tempDir, "summary.txt")
	data, err := ioutil.ReadFile(summaryPath)
	if err != nil {
		t.Fatalf("Expected summary.txt to be created, got error: %v", err)
	}

	if string(data) != "This is a mock response." {
		t.Errorf("Expected 'This is a mock response.', got '%s'", string(data))
	}
}

func TestUpdateMetrics(t *testing.T) {
	// Set up temporary directory
	tempDir, err := ioutil.TempDir("", "test_metrics")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// Define metrics
	metrics := map[string]interface{}{
		"completeness":        0.9,
		"logical_consistency": 0.95,
	}

	// Call updateMetrics
	updateMetrics(tempDir, metrics)

	// Check if metrics.json is created
	metricsPath := filepath.Join(tempDir, "metrics.json")
	data, err := ioutil.ReadFile(metricsPath)
	if err != nil {
		t.Fatalf("Expected metrics.json to be created, got error: %v", err)
	}

	var readMetrics map[string]interface{}
	err = json.Unmarshal(data, &readMetrics)
	if err != nil {
		t.Fatalf("Error unmarshalling metrics.json: %v", err)
	}

	if readMetrics["completeness"] != metrics["completeness"] {
		t.Errorf("Expected completeness %v, got %v", metrics["completeness"], readMetrics["completeness"])
	}

	if readMetrics["logical_consistency"] != metrics["logical_consistency"] {
		t.Errorf("Expected logical_consistency %v, got %v", metrics["logical_consistency"], readMetrics["logical_consistency"])
	}
}

func TestAddWatcherRecursive(t *testing.T) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		t.Fatal(err)
	}
	defer watcher.Close()

	// Set up nested directories
	rootDir, err := ioutil.TempDir("", "test_watcher")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(rootDir)

	subDir := filepath.Join(rootDir, "subdir")
	err = os.Mkdir(subDir, 0755)
	if err != nil {
		t.Fatal(err)
	}

	// Call addWatcherRecursive
	err = addWatcherRecursive(watcher, rootDir)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Check if both directories are being watched
	list := watcher.WatchList()
	for _, want := range []string{rootDir, subDir} {
		found := false
		for _, got := range list {
			if got == want {
				found = true
				break
			}
		}
		Tassert(t, found, "Expected %s to be in watch list", want)
	}
}

func TestGetSummary(t *testing.T) {
	// Create the mock client
	var errClient error
	client, errClient := llm.NewClient("mock-model")
	if errClient != nil {
		t.Fatalf("Error creating mock client: %v", errClient)
	}

	// Call getSummary
	text := "Conversation text"
	summary, err := getSummary(text, client)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	if summary != "This is a mock response." {
		t.Errorf("Expected 'This is a mock response.', got '%s'", summary)
	}
}

func TestErrorHandlingInHandleUserMessage(t *testing.T) {
	// Use a non-existent directory
	nonExistentPath := "non_existent_dir"

	// Create the mock client
	var errClient error
	client, errClient := llm.NewClient("mock-model")
	if errClient != nil {
		t.Fatalf("Error creating mock client: %v", errClient)
	}

	// Call handleUserMessage
	handleUserMessage(nonExistentPath, client, nonExistentPath)

	// Expect no panic and error to be logged
}

func TestErrorHandlingInGetAttachmentsContent(t *testing.T) {
	// Use a non-existent directory
	nonExistentPath := "non_existent_dir"

	// Call getAttachmentsContent
	_, err := getAttachmentsContent(nonExistentPath)
	if err == nil {
		t.Errorf("Expected error when reading attachments from non-existent directory")
	}
}

func TestErrorHandlingInUpdateMetrics(t *testing.T) {
	// Use a read-only directory
	tempDir, err := ioutil.TempDir("", "test_metrics_readonly")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tempDir)

	// Make directory read-only
	err = os.Chmod(tempDir, 0444)
	if err != nil {
		t.Fatal(err)
	}

	// Define metrics
	metrics := map[string]interface{}{
		"test_metric": 1.0,
	}

	// Call updateMetrics
	updateMetrics(tempDir, metrics)

	// Expect error to be logged
}
```
EOF_/home/stevegt/lab/aidss/cmd/aidss/main_test.go

File: /home/stevegt/lab/aidss/llm/openai.go
```go
package llm

import (
	"context"
	"errors"
	"os"

	openai "github.com/sashabaranov/go-openai"
)

type OpenAI struct {
	client *openai.Client
	model  Model
}

type OpenAIProvider struct {
	apiKey string
}

// Model struct represents a language model with its attributes
type Model struct {
	Name        string
	MaxTokens   int
	Temperature float32
}

// Map of model names to Model structs
var openAIModels = map[string]Model{
	openai.GPT4o: {
		Name:        openai.GPT4o,
		MaxTokens:   128000,
		Temperature: 0.7,
	},
	openai.O1Mini: {
		Name:        openai.O1Mini,
		MaxTokens:   128000,
		Temperature: 0.7,
	},
	openai.O1Preview: {
		Name:        openai.O1Preview,
		MaxTokens:   128000,
		Temperature: 0.7,
	},
}

// NewOpenAIProvider creates a new instance of OpenAIProvider
func NewOpenAIProvider() *OpenAIProvider {
	apiKey := os.Getenv("OPENAI_API_KEY")
	if apiKey == "" {
		// Return nil if API key is not set
		return nil
	}

	return &OpenAIProvider{
		apiKey: apiKey,
	}
}

// NewClient returns a new OpenAI client for the given model
func (p *OpenAIProvider) NewClient(modelName string) (Client, error) {
	model, ok := openAIModels[modelName]
	if !ok {
		return nil, errors.New("unsupported model: " + modelName)
	}

	// Create OpenAI client
	client := openai.NewClient(p.apiKey)

	return &OpenAI{
		client: client,
		model:  model,
	}, nil
}

// Models returns the models available in OpenAI
func (p *OpenAIProvider) Models() []string {
	models := make([]string, 0, len(openAIModels))
	for modelName := range openAIModels {
		models = append(models, modelName)
	}
	return models
}

// GenerateResponse implements the Client interface
func (o *OpenAI) GenerateResponse(ctx context.Context, messages []Message) (string, error) {
	// Convert Messages to openai.ChatCompletionMessage
	var chatMessages []openai.ChatCompletionMessage
	for _, msg := range messages {
		chatMessages = append(chatMessages, openai.ChatCompletionMessage{
			Role:    msg.Role,
			Content: msg.Content,
		})
	}

	// Build the request
	req := openai.ChatCompletionRequest{
		Model:       o.model.Name,
		Messages:    chatMessages,
		MaxTokens:   o.model.MaxTokens,
		Temperature: o.model.Temperature,
	}

	// Call the OpenAI API
	resp, err := o.client.CreateChatCompletion(ctx, req)
	if err != nil {
		return "", err
	}

	return resp.Choices[0].Message.Content, nil
}
```
EOF_/home/stevegt/lab/aidss/llm/openai.go

File: /home/stevegt/lab/aidss/llm/mock.go
```go
package llm

import (
	"context"
)

// Mock implements Client interface
type Mock struct {
	model Model
}

// MockProvider implements Provider interface
type MockProvider struct{}

// Mock model
var mockModel = Model{
	Name:        "mock-model",
	MaxTokens:   1000,
	Temperature: 0.7,
}

// NewMockProvider creates a new instance of MockProvider
func NewMockProvider() *MockProvider {
	return &MockProvider{}
}

// NewClient returns a new Mock client
func (p *MockProvider) NewClient(modelName string) (Client, error) {
	return &Mock{
		model: mockModel,
	}, nil
}

// Models returns the models available in Mock
func (p *MockProvider) Models() []string {
	return []string{mockModel.Name}
}

// GenerateResponse returns a mock response
func (m *Mock) GenerateResponse(ctx context.Context, messages []Message) (string, error) {
	return "This is a mock response.", nil
}
```
EOF_/home/stevegt/lab/aidss/llm/mock.go

File: /home/stevegt/lab/aidss/llm/llm.go
```go
package llm

import (
	"context"
	"fmt"
	"sync"
)

// Message represents a chat message.
type Message struct {
	Role    string // e.g., "user", "assistant", "system"
	Content string
}

// Define constants for message roles
const (
	ChatMessageRoleUser      = "user"
	ChatMessageRoleAssistant = "assistant"
	ChatMessageRoleSystem    = "system"
)

// Client is the interface that all LLM clients must implement.
type Client interface {
	GenerateResponse(ctx context.Context, messages []Message) (string, error)
}

// Provider represents an LLM provider.
type Provider interface {
	// NewClient returns a new Client instance for the given model name
	NewClient(modelName string) (Client, error)
	// Models returns a list of model names supported by this provider.
	Models() []string
}

var (
	// Mutex for thread-safe access to the provider registry.
	registryMutex sync.Mutex
	// Map of provider names to Provider instances.
	providers = make(map[string]Provider)
	// Map of model names to provider names.
	modelToProvider = make(map[string]string)
)

// RegisterProvider registers a provider with the llm package.
func RegisterProvider(providerName string, provider Provider) {
	registryMutex.Lock()
	defer registryMutex.Unlock()

	providers[providerName] = provider
	for _, model := range provider.Models() {
		modelToProvider[model] = providerName
	}
}

// Models returns all models from all registered providers.
func Models() []string {
	registryMutex.Lock()
	defer registryMutex.Unlock()

	models := make([]string, 0, len(modelToProvider))
	for model := range modelToProvider {
		models = append(models, model)
	}
	return models
}

// NewClient returns a Client for the given model name.
func NewClient(modelName string) (Client, error) {
	registryMutex.Lock()
	defer registryMutex.Unlock()

	providerName, ok := modelToProvider[modelName]
	if !ok {
		return nil, fmt.Errorf("model %s not supported", modelName)
	}
	provider, ok := providers[providerName]
	if !ok {
		return nil, fmt.Errorf("provider %s not found for model %s", providerName, modelName)
	}
	return provider.NewClient(modelName)
}

func RegisterProviders() {
	// Initialize and register providers
	openAIProvider := NewOpenAIProvider()
	if openAIProvider != nil {
		RegisterProvider("openai", openAIProvider)
	}
	// more providers can be added here

	// Register a mock provider for testing
	mockProvider := NewMockProvider()
	RegisterProvider("mock", mockProvider)
}
```
EOF_/home/stevegt/lab/aidss/llm/llm.go